
---
title: 4. Send ETH
---

# Ethers Quick Start: 4. Send ETH
I've been re-learning `ethers.js` recently, consolidating some details, and also writing a `WTF Ethers Quick Start` for beginners.

**Twitter**: [@0xAA_Science](https://twitter.com/0xAA_Science)

**WTF Academy Community:** [Official website wtf.academy](https://wtf.academy) | [WTF Solidity Tutorial](https://github.com/AmazingAng/WTF-Solidity) | [discord](https://discord.gg/5akcruXrsk) | [WeChat group application](https://docs.google.com/forms/d/e/1FAIpQLSe4KGT8Sh6sJ7hedQRuIYirOoZK_85miz3dw7vA1-YjodgJ-A/viewform?usp=sf_link)

All code and tutorials are open source on github: [github.com/WTFAcademy/WTF-Ethers](https://github.com/WTFAcademy/WTF-Ethers)

-----

In this lecture, we will introduce the `Signer` signer class and its derived `Wallet` wallet class, and use it to send `ETH`.

## `Signer` signer class

`Web3.js` assumes that users will deploy an Ethereum node locally, and the private key and network connection status are managed by this node (actually not the case); while in `ethers.js`, the `Provider` provider class manages the network connection status, and the `Signer` signer class or `Wallet` wallet class manages the keys, which is secure and flexible.

In `ethers`, the `Signer` signer class is an abstraction of an Ethereum account that can be used to sign messages and transactions, and send signed transactions to the Ethereum network, changing the blockchain state. The `Signer` class is an abstract class that cannot be instantiated directly. We need to use its subclass: the `Wallet` wallet class.

## `Wallet` wallet class

The `Wallet` class inherits from the `Signer` class, and developers can use it to sign transactions and messages like an externally owned account (`EOA`) that contains a private key.

Below we introduce a few ways to create a `Wallet` instance:

### Method 1: Create a random wallet object

We can use the `ethers.Wallet.createRandom()` function to create a `Wallet` object with a random private key. The private key is generated by a cryptographically secure entropy source. If there is no secure entropy source in the current environment, an error will be thrown (this method cannot be used on the online platform `playcode`).

```javascript
// Create a random wallet object
const wallet1 = new ethers.Wallet.createRandom()
```

### Method 2: Create a wallet object with a private key

If we know the private key, we can use the `ethers.Wallet()` function to create a `Wallet` object.
Sure, here is the translation:

```javascript
// Create a wallet object with a private key and provider
const privateKey = '0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b'
const wallet2 = new ethers.Wallet(privateKey, provider)
```

### Method 3: Create a wallet object from a mnemonic phrase

If we know the mnemonic phrase, we can use the `ethers.Wallet.fromMnemonic()` function to create a `Wallet` object.


```javascript
// Create a wallet object from a mnemonic phrase
const wallet3 = new ethers.Wallet.fromMnemonic(mnemonic.phrase)
```
### Other methods: Create a wallet object from a JSON file
The above three methods can meet most of the needs. Of course, you can also use `ethers.Wallet.fromEncryptedJson` to decrypt a `JSON` wallet file and create a wallet instance. The `JSON` file is the `keystore` file, which usually comes from wallets such as `Geth`, `Parity`, etc. Those who have built an Ethereum node with `Geth` will not be unfamiliar with the `keystore` file.

## Send `ETH`

We can use the `Wallet` instance to send `ETH`. First, we need to construct a transaction request, in which we declare the receiving address `to` and the amount of `ETH` to send `value`. The transaction request type `TransactionRequest` can contain information such as the sender `from`, nonce value `nounce`, request data `data`, etc., which will be explained in more detail in later tutorials.

```javascript
    // Create a transaction request, parameters: to is the receiving address, value is the amount of ETH
    const tx = {
        to: address1,
        value: ethers.parseEther("0.001")
    }
```

Then, we can use the `sendTransaction` method of the `Wallet` class to send the transaction, wait for the transaction to be on the chain, and get the receipt of the transaction. It's very simple.

```javascript
    // Send transaction, get receipt
    const receipt = await wallet2.sendTransaction(tx)
    await receipt.wait() // Wait for confirmation on the chain
    console.log(receipt) // Print transaction details
```

Sure, here is the translation:

## Code example

### 1. Create a `Provider` instance

```javascript
// Use the Wallet class to send ETH
// Since playcode does not support the ethers.Wallet.createRandom() function, we can only use VScode to run this lecture code
import { ethers } from "ethers";

// Connect to the Ethereum test network using Alchemy's rpc node
// To prepare alchemy API, you can refer to https://github.com/AmazingAng/WTFSolidity/blob/main/Topics/Tools/TOOL04_Alchemy/readme.md 
const ALCHEMY_GOERLI_URL = 'https://eth-goerli.alchemyapi.io/v2/GlaeWuylnNM3uuOo-SAwJxuwTdqHaY5l';
const provider = new ethers.JsonRpcProvider(ALCHEMY_GOERLI_URL);
```

### 2. Create a `Wallet` instance with three different methods

- Create a `Wallet` object with a random private key. This method creates a standalone wallet, and we need to use the `connect(provider)` function to connect to the Ethereum node. This method creates a wallet that can use `mnemonic` to get the mnemonic phrase.

```javascript
// Create a random wallet object
const wallet1 = ethers.Wallet.createRandom()
const wallet1WithProvider = wallet1.connect(provider)
const mnemonic = wallet1.mnemonic // Get the mnemonic phrase
```

- Create a `Wallet` object with a private key and a `Provider` instance. This method creates a wallet that cannot get the mnemonic phrase.
```javascript
// Create a wallet object with a private key and provider
const privateKey = '0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b'
const wallet2 = new ethers.Wallet(privateKey, provider)
```

- Create a `Wallet` object with a mnemonic phrase. Here we use the mnemonic phrase of `wallet1`, so the private key and public key of the created wallet are the same as `wallet1`.

```javascript
// Create a wallet object from a mnemonic phrase
const wallet3 = ethers.Wallet.fromPhrase(mnemonic.phrase)
```

### 3. Get wallet address

Use the `getAddress()` function to get the wallet address.


```javascript
    const address1 = await wallet1.getAddress()
    const address2 = await wallet2.getAddress() 
    const address3 = await wallet3.getAddress() // Get address
    console.log(`1. Get wallet address`);
    console.log(`Wallet 1 address: ${address1}`);
    console.log(`Wallet 2 address: ${address2}`);
    console.log(`Wallet 3 address: ${address3}`);
    console.log(`Are wallet 1 and wallet 3 addresses the same: ${address1 === address3}`);
    
```
Sure, here is the translation:

### 4. Get mnemonic phrase

Use the wallet object's `mnemonic.phrase` member to get the mnemonic phrase:

```javascript
console.log(`Wallet 1 mnemonic phrase: ${wallet1.mnemonic.phrase}`)
```
![Get mnemonic phrase](img/4-2.png)

### 5. Get private key
Use the wallet object's `privateKey` member to get the private key:

```javascript
    console.log(`Wallet 2 private key: ${wallet2.privateKey}`)
```
### 6. Get the number of interactions on the chain
Use the `getTransactionCount()` function to get the number of interactions on the chain.

```javascript
    const txCount1 = await wallet1WithProvider.getTransactionCount()
    const txCount2 = await wallet2.getTransactionCount()
    console.log(`Wallet 1 number of transactions sent: ${txCount1}`)
    console.log(`Wallet 2 number of transactions sent: ${txCount2}`)
```
### 7. Send `ETH`

We use `wallet2` to send `0.001 ETH` to `wallet1`, and print the wallet balance before and after the transaction. Since `wallet1` is a newly created random private key wallet, the balance before the transaction is `0`, and the balance after the transaction is `0.001 ETH`.


```javascript
    // 5. Send ETH
    // If this wallet has no goerli testnet ETH left, go to the faucet to get some, wallet address: 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2
    // 1. chainlink faucet: https://faucets.chain.link/goerli
    // 2. paradigm faucet: https://faucet.paradigm.xyz/
    console.log(`\n5. Send ETH (testnet)`);
    // i. Print balance before transaction
    console.log(`i. Balance before sending`)
    console.log(`Wallet 1: ${ethers.formatEther(await provider.getBalance(wallet1WithProvider))} ETH`)
    console.log(`Wallet 2: ${ethers.formatEther(await provider.getBalance(wallet2))} ETH`)
    // ii. Construct transaction request, parameters: to is the receiving address, value is the amount of ETH
    const tx = {
        to: address1,
        value: ethers.parseEther("0.001")
    }
    // iii. Send transaction, get receipt
    console.log(`\nii. Wait for transaction confirmation on the blockchain (takes a few minutes)`)
    const receipt = await wallet2.sendTransaction(tx)
    await receipt.wait() // Wait for confirmation on the chain
    console.log(receipt) // Print transaction details
    // iv. Print balance after transaction
    console.log(`\niii. Balance after sending`)
    console.log(`Wallet 1: ${ethers.formatEther(await provider.getBalance(wallet1WithProvider))} ETH`)
    console.log(`Wallet 2: ${ethers.formatEther(await provider.getBalance(wallet2))} ETH`)
```
Sure, here is the translation:

## Summary

In this lecture, we introduced the `Signer` signer class and the `Wallet` wallet class, used the wallet instance to get the address, mnemonic phrase, private key, number of interactions on the chain, and sent `ETH`.

